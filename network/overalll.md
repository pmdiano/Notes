在规范情况下，对磁盘文件调用`read()`将阻塞进程，一直到数据被复制到进程用户态内存空间。`write()`则不同，它会在数据被复制到内核缓冲区后立即返回。如果使用`O_SYNC`标志打开文件，则对写文件操作产生影响，它是的`write()`必须等待数据真正写入磁盘后才返回。

同步非阻塞I/O调用不会等待数据的就绪，如果数据不可读或者不可写，它会立即告诉进程。非阻塞I/O一般只针对网络I/O有效，我们只要在socket的选项设置中使用`O_NONBLOCK`即可，这样对于该socket的`send()`或`recv()`便采用非阻塞方式值得注意的是，对于磁盘I/O，非阻塞I/O并不产生效果。

多路I/O就绪通知可以帮助我们快速获得就绪的文件描述符，当得知数据就绪后，就访问数据本身而言，仍然需要选择阻塞或非阻塞的访问方式。

TCP/IP诞生于4.1BSD，select诞生于4.2BSD。4.4BSD Lite很多现在自由版UNIX的基础。BSD在发展中衍生出3个主要的分支：FreeBSD、OpenBSD和NetBSD。

select系统调用诞生于1983年的4.2BSD。输入一个包含多个文件描述符的数组，当返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。它的一个缺点在于单个进程能够监视的文件描述符数量存在最大限制，Linux上一般为1024。同时其会对所有socket进行一次线性扫描，这也浪费了一定的开销。

poll诞生于1986年的System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。select和poll将就绪的文件描述符告诉进程后，如果进程没有对其进行I/O操作，那么下次调用select或poll的时候将再次报告这些文件描述符，所以它们一般不会丢失。这种方式称为水平触发（Level Triggered）。

SIGIO提供于Linux 2.4，它通过实时信号来实现select/poll的通知方法，但SIGIO告诉我们哪些FD刚刚变成就绪状态，它只说一遍。这种方式称为边缘触发（Edge Triggered）。

/dev/poll和/dev/epoll见于Solaris和Linux2.4的一个补丁，通过ioctl来等待事件通知。没有提供直接的内核支持。

epoll出现于Linux2.6，公认为Linux2.6下性能最好的多路I/O就绪通知方法。默认水平触发，边缘触发则需要在时间注册时增加EPOLLET选项。

kqueue实现于FreeBSD中，像epoll一样可以设置水平触发或边缘触发，但他的API在很多平台都不支持。

内存映射可以提高磁盘I/O的性能，它无需使用read或者write等系统调用来访问文件，而是通过mmap系统调用来建立内存和磁盘文件的关联，然后像访问内存一样自由地访问文件。

open系统调用中增加参数选项O_DIRECT，用它打开的文件便可以绕过内核缓冲区直接访问，这样便避免了CPU和内存的多余时间开销。MySQL中，对于Innodb存储引擎，在my.cnf配置中，可以在分配Innodb数据空间文件的时候，通过使用raw分区跳过内核缓冲区，实现直接I/O。另外还提供了`innodb_flush_method = O_DIRECT`选项。O_SYNC只对写数据有效，将写入内核缓冲区的数据立即写入磁盘，但是仍然要经过内核缓冲区。

sendfile系统调用可以将磁盘文件的特定部分直接传送到代表客户端的socket描述符，而不是先从磁盘建经过内核缓冲区到达用户内存空间，然后又被送到网卡对应的内核缓冲区，接着再被送入网卡进行发送。Linux2.4引入了khttpd的内核级web服务程序，只处理静态文件的请求。在OpenBSD和NetBSD中没有提供对sendfile的请求。

异步I/O：`aio_read()`, `aio_write()`, `aio_error()`。然而Linux2.6.16中AIO的实现方式是基于LinuxThreads内核级线程库，性能大打折扣。

服务器并发策略：
+ 一个进程处理一个连接，非阻塞I/O，如Apache
+ 一个线程处理一个连接，非阻塞I/O，Apache的worker多路处理模块便采用这种方法。实际测试中，这种方式的表现并不比prefork有太大的优势。人们几乎很少使用它。
+ 一个进程处理多个连接，非阻塞I/O，使用select/poll/epoll
+ 一个线程处理多个连接，异步I/O，目前很少有web服务器支持这种真正意义上的异步I/O。

HTTP响应头中同时含有Expires和Cache-Control时，浏览器会优先考虑Cache-Control。对于没有Cache-Control的情况，浏览器则会服从Expires的指示。

Varnish：反向代理（Caching HTTP reverse proxy）。varnishstat：命令行的状态监控程序。

Cacti：监控平台。

ESI：Edge Side Includes，反向代理服务器可以做到这一点，可以像SSI（Server Side Include）一样在网页中嵌入子页面。不同的是，SSI是在Web服务器端组装内容，而ESI则是在HTTP代理服务器上组装内容，包括反向代理。

HTTP层面以下的负载均衡：数据链路层（第二层），网络层（第三层），传输层（第四层）都可以实现不同机制的负载均衡，这些负载均衡调度器的工作必须由Linux内核来实现。Linux 2.4内核开始，其内置的Netfilter模块便可以修改IP数据包。iptables是用户空间一个命令行工具，可以通过它来对Netfilter的过滤表进行插入、修改或删除等操作。iptables最多的应用场景就是防火墙了。比如以下这段简单的iptables规则，告诉内核只允许外部网络通过TCP与这台服务器的80端口建立连接，这项规则可以很好地应用在Web服务器上：
```
iptables -F INPUT
iptables -A INPUT -i eth0 -p tcp --dport 80 -j ACCEPT
iptables -P INPUT DROP
```

IPVS（IP Virtual Server）也工作在Linux内核中，更专注于实现IP负载均衡。IPVS的管理工具是ipvsadm，提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统，也成为LVS（Linux Virtual Server）。

不同于NAT机制，直接路由方式下（LVS-DR）的负载均衡调度器工作在数据链路层（第二层），通过修改数据包的目标MAC地址，将数据包转发到实际服务器上，并且实际服务器的响应数据包将直接发送给客户端，而不经过调度器。实际服务器必须接入外部网络。（RFC1918规定的私有IP地址范围是：10.0.0.0 - 12.255.255.255, 即10/8 prefix; 172.16.0.0 - 172.31.255.255，即172.16/12 prefix；192.168.0.0 - 192.168.255.255，即192.168/16 prefix）。与LVS-DR的原理非常类似，基于IP隧道（IP Tunneling）的负载均衡系统同样可以用LVS来实现，称为LVS-TUN。一些CDN服务便是基于IP隧道技术来实现的。

对于调度器，转移请求的机制注定它存在单点故障。为此，我们必须通过其他方法来有效实现故障平滑转移。Heartbeat可以很好地解决这个问题。简单地说，我们可以准备一台备用调度器，通过运行Heartbeat对主调度器进行心跳检测，一旦发现主调度器停止心跳，便立即启动故障转移，接管主调度器，这个接管过程包括IP别名变更、相关服务的启动等。随后，一旦主调度器恢复后，备用调度器便自动将相关资源转交回主调度器。如果希望让物理层设备的网线不存在单点故障，可以用Linux Bonding技术将多条线路绑定在一台服务器的多个网卡上。查看内核是否支持Bonding：`modprobe -l | grep bonding`。

NFS由Sun于1984年开发，直到现在一直都是主流异构平台实现文件共享的首选方案。NFS基于RPC（Remote Procedure Control）协议，和HTTP一样都工作在应用层。对于传输层，RPC服务默认使用了UDP。NFS的服务器端程序采用多进程（nfsd）模型，进程数固定，默认是4.可以通过修改`/etc/sysconfig/nfs`将NFS服务器端进程数适当提高：`USE_KERNEL_NFSD_NUMBER="64"`。无论怎么对NFS进行性能优化，NFS注定不适合作为I/O密集型文件的共享方案，但是作为一般的用途，比如提供站点内部的资源共享，它的优势在于容易搭建，而且可以减少不必要的数据冗余。但是单一的NFS文件服务器不支持扩展，容易成为性能的瓶颈。

内容分发和同步可以通过两种方式来实现复制，分别为主动分发和被动同步，主要区别在于复制的发起方和触发方式不同。WebDAV是HTTP的扩展协议，RFC2518，可以使用litmus来测试Web服务器软件对于WebDAV的支持程度。WebDAV的定义方式与RESTful风格十分接近，或者说RESTful是对WebDAV风格的回归。SCP或WebDAV是主动分发方式。被动同步方式下，接收文件的一端主动向文件服务器发起同步请求，并根据两端文件列表的差异，有选择性地进行更新。rsync工具，rsync的独立服务器端进程rsyncd，配置是`/etc/rsyncd.conf`。rsync在同步文件时需要分析目录中每一个文件的更新标记。Hash tree可以显著改善性能。虽然操作系统本身对于文件的修改并不会自动更新上级目录的修改时间（VI编辑过的文件会），但Linux内核中的inotify模块可以帮助我们完成这一工作。我们可以通过inotify提供的API来编写守护进程，持续不断地监视文件修改事件，一旦发现某个文件被修改，便随之更新上级甚至更上一级目录的修改时间，直到被同步目录的根节点。

数据库的扩展分为读写分离（主从扩展），垂直分区（将不同的数据库分布到不同的服务器上），以及水平分区（Sharding，将统一数据表中的记录通过特定的算法进行分离，分别保存在不同的数据表中，从而可以部署在不同的数据库服务器上）。