# 第三章 对象
JavaScript中的类型：number, string, boolean (true and false), null, undefined, object。Number，string，和boolean 有方法，但他们是不可变（immutable）的。Object（对象）是可变的键值对集合（mutable keyed collections）。
# 第四章 函数
## 函数的定义（Function Literal）
函数的定义由四部分组成：
+ 关键字function 
+ 函数名（可省略） 
+ 一组圆括号和其内的零至多个函数参数名，参数名之间以逗号隔开 
+ 一组大括号和其内的语句（statement） 
```javascript
// Create a variable called add and store a function
// in it that adds two numbers
var add = function (a, b) {
  return a + b;
};
```
函数定义可以出现在任何表达式（expression）可以出现的地方。定义在另一个函数内的函数不仅可以读写（access）它自身的参数和变量，还可以读写包含它的函数的参数和变量，此谓闭包（closure）。
## 函数的调用（Invocation）
除了函数参数外，每个函数被调用时还会接收额外两个参数：this和arguments。this的值由调用模式
（invocation pattern）决定。JavaScript共有四种调用模式：
+ 方法调用模式（Method Invocation Pattern）
调用的函数为某个对象的属性。this 绑定至此对象。
+ 函数调用模式（Function Invocation Pattern）
函数不为某个对象的属性。此时this 绑定至全局对象（the global object），而不是包含此函数定义的函数中的this。有如下workaround：
```javascript
myObject.double = function() {
  var that = this;  // Workaround.

  var helper = function() {
    that.value = add(that.value, that.value);
  };

  helper(); // Invoke helper as a function.
};

myObject.double();
document.writeln(myObject.value);
```
+ 构造调用模式（Constructor Invocation Pattern）
当函数调用以new 为前缀时，一个新对象会被创建，此对象有一个隐藏的指向这个函数的prototype的链接，而this则绑定至次对象。约定构造函数以大写字母开头。此种方式并不推荐使用。
```javascript
// Create a constructor function called Quo.
// It makes an object with a status property.

var Quo = function (string) {
  this.status = string;
};

// Give all instances of Quo a public method
// called get_status.

Quo.prototype.get_status = function() {
  return this.status;
};

// Make an instance of Quo.

var myQuo = new Quo("confused");

document.writeln(myQuo.get_status()); // confused
```
+ 应用调用模式（Apply Invocation Pattern） 
Apply 调用有两个参数。第一个是用户指定的绑定至this 的值。第二个是一个参数array。
```javascript
var array = [3, 4];
var sum = add.apply(null, array); // sum is 7

var statusObject = {
  status: 'A-OK'
};
var status = Quo.prototype.get_status.apply(statusObject); // status is 'A-OK'
```
## arguments 参数
arguments 参数并不是真正的array，只是一个像array的对象。它有length属性，但没有array有的方法。
## 返回
函数一定会返回一个值。如果函数体中没有return，undefined 被返回。构造函数调用模式中如果返回的不是一个对象，那么返回的是this。
## 异常
抛出的异常对象应含有name 和message 属性。
## 扩展（Augmenting Types）
基本类型也可以扩展。
```javascript
// Augment Function.prototype conditionally, make a method available to all functions:
Function.prototype.method = function (name, func) {
  if (!this.prototype[name]) {
    this.prototype[name] = func;
    return this;
  }
};

// Get integer part of a number
Number.method('integer', function () {
  return Math[this < 0 ? 'ceil' : 'floor'](this);
});
document.writeln((-10 / 3).integer());  // -3

// Remove spaces from the ends of a string
String.method('trim', function() {
  return this.replace(/^\s+|\s+$/g, '');
});
document.writeln('"' + "   neat    ".trim() + '"');
```
## 范围（Scope）
不像C语言，JavaScript并没有块范围（Block Scope），定义在一对花括弧内的变量在括弧外也是可见的。JavaScript有函数范围，即定义在函数内的变量在函数外是不可见的。
## 闭包（Closure）
定义在函数内部的函数可以access外面函数的actual变量，而不是外面函数的变量的拷贝。
```javascript
// BAD EXAMPLE
// A funcion that assigns event handler functions to an array of nodes the wrong way.
// When you click a node, an alert box is supposed to display the ordinal of the node.
// But it always displays the number of nodes instead.
var add_the_handlers = function (nodes) {
  var i;
  for (i = 0; i < nodes.length; i += 1) {
    nodes[i].onclick = function (e) {
      alert(i);
    };
  }
};

// BETTER EXAMPLE
var add_the_handlers = function (nodes) {
  var helper = function (i) {
    return function (e) {
      alert(i);
    };
  };
  var i;
  for (i = 0; i < nodes.length; i += 1) {
    nodes[i].onclick = helper(i);
  }
};
```
避免在循环内部创建函数。
## 模块（Module）
```javascript
String.method('deentityify', function () {
  var entity = {
    quot: '"',
    lt:   '<',
    gt:   '>'
  };

  return function () {
    return this.replace(/&([^&;]+);/g,
      function (a, b) {
        var r = entity[b];
        return typeof r === 'string' ? r : a;
      }
    );
  };
}());

document.writeln('&lt;&quot;&gt;'.deentityify()); // <">
```
## Curry
因为arguments不是array，它没有concat方法，所以我们用slice来实现：
```javascript
Function.method('curry', function () {
  var slice = Array.prototype.slice,
      args = slice.apply(arguments),
      that = this;
  return function () {
    return that.apply(null, args.concat(slice.apply(arguments)));
  };
});

var add1 = add.curry(1);
document.writeln(add1(6));  // 7
```
## Memoization
```javascript
var fibonacci = (function () {
  var memo = [0, 1];
  var fib = function (n) {
    var result = memo[n];
    if (typeof result !== 'number') {
      result = fib(n-1) + fib(n-2);
      memo[n] = result;
    }
    return result;
  };
  return fib;
}());

// More generally
var memoizer = function (memo, formula) {
  var recur = function (n) {
    var result = memo[n];
    if (typeof result !== 'number') {
      result = formula(rucur, n);
      memo[n] = result;
    }
    return result;
  };
  return recur;
};

var fibonacci = memoizer([0, 1], function (recur, n) {
  return recur(n-1) + recur(n-2);
});
var factorial = memoizer([1, 1], function (recur, n) {
  return n * recur(n-1);
});
```

